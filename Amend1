
#ifndef BOOK_MANAGEMENT_GUARD__H 
#define BOOK_MANAGEMENT_GUARD__H

#include <stdio.h>
#include <stdlib.h>
#include<windows.h>
#include <string.h>
/*You can extend the structs (Book and BookArray) defined in this head file;
  However, you may not change the function prototypes. 
  You are also free to add additional head files and data structures as needed. 
*/


typedef struct _Book {
	    unsigned int id; //Book ID
		char *title; //book title
		char *authors; //comma separated list of authors
		unsigned int year; // year of publication
		unsigned int copies; //number of copies the library has
		struct _Book *nextbook;//定义指针域 
}Book;

typedef struct _BookArray {
	 Book* array; // pointer to array (or linked list) of struct Book.
	 unsigned int length; // number of elements in the (Book*) array 
}BookArray;

typedef Book *pbook;

pbook bookhead = NULL;//创建头指针，初始值为NULL 

int store_books(FILE *file);
int load_books(FILE *file);
pbook Last_books();
int add_book(Book book);
int remove_book(Book book);
BookArray find_book_by_title (const char *title);
BookArray find_book_by_author (const char *author);
BookArray find_book_by_year (unsigned int year);
int Add_book();
int Remove_book();

//saves the database of books in the specified file
//returns 0 if books were stored correctly, or an error code otherwise
int store_books(FILE *file)//已经给了特定文件的指针了 
{
	int a;
	pbook sbook = bookhead ,lastbook = NULL;
	lastbook = Last_books();
	if(lastbook=NULL){
		lastbook = sbook;
	} 
	file=fopen("bookfile","ab+");   //以追加的方式打开名字为mybook的二进制文件 
	if(file==NULL)
	{
		printf("file can't be opened");
		return 1; 
	}
	if (sbook==NULL){
		return 1;//链表还为空，没有书籍需要存入文件 
	}
	while(sbook!=NULL){
		while(1){
			if(sbook!=lastbook){ //将已经存储的书筛除 
				sbook=sbook->nextbook;
			}
			else{
				sbook=sbook->nextbook;
				break;
			}
		}
		if(sbook==NULL){
			return 1;//没有需要存入的书 
		}
		a=fwrite(sbook,sizeof(struct _Book),1,file);//将链表中的内容内容存入file所指向的文件中
		if(a!=1)   
		{
			printf("An error occurred while writing to the file");
			return 1;
		}
		sbook = sbook->nextbook; 	
	}
	fclose(file);    //关闭文件
	return 0;	
} 
//loads the database of books from the specified file
//the file must have been generated by a previous call to store_books()
//returns 0 if books were loaded correctly, or an error code otherwise
int load_books(FILE *file){
	file=fopen("bookfile","ab+");  //打开文件
	pbook bookpa = NULL, bookpb = NULL, bookpc = NULL;
	if(file==NULL)
	{
		printf("the file can not be opened successfully\n");
		return 1;
	}
	while(!feof(file))        //判断读写标志是否移到文件末尾 
	{
	    bookpa=(pbook)malloc(sizeof(Book)); //用malloc在内存申请一段空间 
	   fread(bookpa,sizeof(struct _Book),1,file);     //将file所指向文件的内容传递给bookpa 
	   if(bookhead==NULL)
	   {
	      bookhead=bookpa;
	      bookpb=bookpa;
	    }
	    else             //建立链表 
	    {
	    	bookpc=bookpb;
	    	bookpb->nextbook=bookpa;
	    	bookpb=bookpa;
		}
    }
    if(bookpc!=NULL)  	//文件里没有数据 
       bookpc->nextbook=NULL;
    else
       bookhead=NULL;
    fclose(file);    //关闭文件
	return 0; 
}

pbook Last_books(){
	FILE *file1;
	file1=fopen("bookfile","ab+");  //打开文件
	pbook bookpa = NULL, bookpb = NULL, bookpc = NULL, bookpd=NULL;
	bookpd=bookhead;
	if(file1==NULL)
	{
		printf("the file can not be opened successfully\n");
	}
	while(!feof(file1))        //判断读写标志是否移到文件末尾 
	{
	    bookpa=(pbook)malloc(sizeof(Book)); //用malloc在内存申请一段空间 
	   fread(bookpa,sizeof(struct _Book),1,file1);     //将file所指向文件的内容传递给bookpa 
	   if(bookpd==NULL)
	   {
	      bookpd=bookpa;
	      bookpb=bookpa;
	    }
	    else             //建立链表 
	    {
	    	bookpc=bookpb;
	    	bookpb->nextbook=bookpa;
	    	bookpb=bookpa;
		}
    }
    if(bookpc!=NULL)  	 
       bookpc->nextbook=NULL;
    else			  //文件里没有数据 
       bookpd=NULL;
    fclose(file1);    //关闭文件
	return bookpc; 
}

//添加新书籍的ID，作者等等 
int Add_book()
{
	do
	{
		pbook padd = NULL;
		FILE *file;    //指向文件的指针 
		int s,f;
		padd=(pbook)malloc(sizeof(Book));//申请内存空间
		if(padd == NULL){			//如果申请内存失败，则添加book失败，返回1 
			printf("memory allocation failed\n");
			return 1;
		}
		add_book(*padd);
		//添加图书信息
		printf(" Please input BOOK id ");    
		scanf("%s",&padd->id);
		printf(" Please input BOOK title ");
		scanf("%s",&padd->title);
		printf("Please input BOOK authors");
		scanf("%s",&padd->authors);
		printf("Please input Year of publication");
		scanf("%s",&padd->year);
		printf("Please input the number of copies of the book\n");
		scanf("%s",&padd->copies);
		padd->nextbook = NULL;//新增的节点位于链表末端，所以为null 
		system("pause");
		printf("|                                              |");
		printf("| Saved successfully. Do you want to continue  |");
		printf("| 1.YES                                    2.NO|\n"); 
		scanf("%d",&s);
		do{
			if(s=='1')
			{
				break;
			}	 
			else if(s=='2')
			{
				return 0;
			}			
		 }while(1);  
	}while(1);
}

//adds a book to the ones available to the library
//returns 0 if the book could be added, or an error code otherwise
int add_book(Book book)
{
	pbook bookpr = bookhead;
	if(bookhead == NULL){ //如果头指针是NULL,说明可以从头添加节点 
		bookhead = &book;
	}else{
		while(bookpr->nextbook!= NULL){
				bookpr = bookpr->nextbook;
		}
		bookpr->nextbook = &book;
	}
	return 0; 
}

//removes a book from the library
//returns 0 if the book could be successfully removed, or an error code otherwise.
int remove_book(Book book);
{
	do
	{
		system("cls");
		color(9);
		FILE *fp;
		book head,p,pre=NULL; 
		int j=0,x,i=11;
		char name[10];
		char t,c,ch;
		head=ss();    //调用函数，返回表头地址 
		toxy(48,10);
		printf("请输入你要删除的图书的书名：");
		scanf("%s",name);
		p=head;
		while(p!=NULL)
		{
			p->x=0;
			p=p->next;
		}
		p=head;
		toxy(20,5);
		printf("***********************************************图书信息******************************************************");
		toxy(20,8);
		printf("-------------------------------------------------------------------------------------------------------------");
		toxy(20,9);
		printf("登录号        书名        作者名         图书类别         出版单位         出版时间          价格        数量");
		toxy(20,10);
		printf("-------------------------------------------------------------------------------------------------------------");
		while(p!=NULL)
		{
			if(p!=NULL&&strcmp(p->name,name)==0)
			{
				toxy(20,i);
				j++;
				printf("%d:%s%14s%14s%14s   %14s   %18s         %.2f%12d\n",j,p->number,p->name,p->author,p->type,p->publish,p->time,p->price,p->num);
				p->x=j;
				i++;
			}
			p=p->next;
		}
		if(j==0)                   //如果j=0，即没有进入前面的搜索循环，也就是没有找到相应的信息 
		{ 
			toxy(50,i);
			printf("没有找到相应的信息！(按0返回，按1重新搜索)");
			while(1)               //死循环是为了防止除0和1的其他按键干扰 
			{
				ch=getch();
				if(ch=='0')
				{
					menu();break;
				}
				else if(ch=='1')
				{
					break;
				}
			}
			if(ch=='1')     //如果输入的ch等于1，则结束本次循环 
			   continue;
		}
		while(1)
		{
			toxy(45,i);
			printf("请输入您要删除的图书的编号：");
			scanf("%d",&x);getchar();
			if(x>j||x==0)
			{
				toxy(45,++i);
				printf("输入错误，请重新输入!");
				Sleep(500);
			}
			else
			{
				break;
			}
		}
		color(7);
		toxy(46,8);
		printf("-------------------------");
		toxy(46,9);
		printf("|                       |");
		toxy(46,10);
		printf("|     是否确认删除？    |");
		toxy(46,12);
		printf("| 1.是             2.否 |");
		toxy(46,13);
		printf("|                       |");
		toxy(46,14);
		printf("-------------------------");
		while(1)
		{
			t=getch();
			if(t=='1')
			{
				break;
			} 
			else if(t=='2')
			{
				menu();
			}
		}
		//下面是remove_book函数 
		p=head;
		while(p!=NULL&&p->x!=x)
		{
			pre=p;
			p=p->next;
		}
		if(p!=NULL)
		{
			if(pre==NULL)
			{
				head=head->next;
			}
			else
			{
				pre->next=p->next;
			}
		}
		free(p);
		fp=fopen("mybook","wb");
		if(fp==NULL)
		{
			printf("cannot open file"); 
		}
		if(fwrite(head,N,1,fp)!=1)
		{
			printf("write error!"); 
		}
		fclose(fp);
		if(head!=NULL)
		{
			p=head->next;
			fp=fopen("mybook","ab");
			if(fp==NULL)
			{
				printf("cannot open file");
			}
			while(p!=NULL)
			{
				if(fwrite(p,N,1,fp)!=1)
				{
					printf("write error!");
				}
				p=p->next;
			}
			fclose(fp);
		}
		system("cls");
		toxy(46,10);
		printf("正在删除，请稍后....");
		Sleep(500);
		system("cls");
		toxy(46,8);
		printf("-------------------------");
		toxy(46,9);
		printf("|                       |");
		toxy(46,10);
		printf("|  删除成功，是否继续？ |");
		toxy(46,12);
		printf("| 1.是             2.否 |");
		toxy(46,13);
		printf("|                       |");
		toxy(46,14);
		printf("-------------------------");
		while(1)
		{
			c=getch();
			if(c=='1')
			{
				break;
			}
			else if(c=='2')
			{
				menu();
			}
		}
	}while(1);
}


//finds books with a given title.
//returns a BookArray structure, where the field "array" is a newly allocated array of books, or null if no book with the 
//provided title can be found. The length of the array is also recorded in the returned structure, with 0 in case
//array is the null pointer.
BookArray find_book_by_title (const char *title);

//finds books with the given authors.
//returns a BookArray structure, where the field "array" is a newly allocated array of books, or null if no book with the 
//provided title can be found. The length of the array is also recorded in the returned structure, with 0 in case
//array is the null pointer.
BookArray find_book_by_author (const char *author);

//finds books published in the given year.
//returns a BookArray structure, where the field "array" is a newly allocated array of books, or null if no book with the 
//provided title can be found. The length of the array is also recorded in the returned structure, with 0 in case
//array is the null pointer.
BookArray find_book_by_year (unsigned int year);


#endif
